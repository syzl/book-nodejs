# 内存控制

> 记得有一些测试代码

## V8 内存控制机制

1. V8 内存分配有限制，可以动过为node增加后缀自定义限制
2. V8 的内存回收涉及各种垃圾回收算法
  首先，内存分代
  Scavenge算法， 采用了Cheney算法
    Cheney算法采用复制的方式实现垃圾回收。
    将堆内存一分为二，一个处于使用中状态，另一个是闲置状态。进行回收时，将使用中状态的这一半内存复制到闲置中的一半之中，复制过程之中只保留存活的内存，复制完成之后，对调使用中/闲置状态。
    缺点是只能使用堆内存的一半。优点，做到完全的垃圾回收。
    适用场景：当内存对象存活之间较短时，保留的存活内存比例会很小，复制起来很快，即内存整理很快。
  在新生代内存中使用Scavenge算法，还实现了分代晋升机制。

  Mark-Sweep & Mark-Compact
    Mark-Sweep对内存对象进行标记，清理的时候只清理没有标记的对象。
    不会浪费一半内存空间。
    适用场景：老生代内存中没有标记的对象占小部分。清理的工作量小，效率高。
    缺点：会造成内存不连续，无法完成过大内存对象的分配。
    Mark-Compact 将后一半的存活对象向前一半留下的空隙中移动。移动完之后，直接清理边界外内存。得到一半左右大小的连续内存空间。
    V8 倾向于只在需要分配大内存对象时，进行Mark-Compact。

3. Incremental Marking
  进行垃圾回收时，应用逻辑‘全停顿’，防止应用逻辑与垃圾回收器处理的内存情况不一致。
  新生代垃圾回收全停顿时间很短，影响很小。老生代内存较大，存活对象多。如果进行Mark-Compact，停顿时间会很长。
  为解决此问题，V8对内存添加增量标记（Incremental Marking），将垃圾回收分步进行。全停顿时间减少到1/6左右。
  后续，引入延迟清理（Lazy sweeping）， 增量式整理（incremental compaction），多CPU的并行标记，并行整理。


## 使用内存， 闭包

1.  作用域。
  此法作用域。
  在ES6 中，可以单独的写一个 `{ ... } `词法块。在ES5中 `{ ... } ` 需要跟着if，for出现，不能单独使用。
  标识符查找。
    变量名，更应该叫标识符。
  作用域链
    当前作用域找不到要取的标识，会想上一层作用域查找。直到顶层作用域。
  变量主动释放
    使用delete有可能干扰V8的内存优化。采用赋值解除引用会更好。
    设想区别，赋值解除，还保有标识符，delete没有标识符。
    示例：
    ```
    var b = {},c = {}
    b.a = 'b-a', c.a='c-a'
    console.log(b, ' ' ,c)
    delete b.a
    c.a = undefined
    console.log(b, ' ' ,c)
    for ( key in b){
      console.info('keys in b :', key, b[key])
    }
     // 什么也不出现
    console.log('---------')

    for ( key in c){
      console.info('keys in c :', key, b[key])
    }
     // 会出现 “keys in c : a undefined”
    ```
2. 闭包
  当作用域执行完毕之后，一般情况将被回收。
  使用高阶函数，将该作用域之内的某个函数与外部对象建立引用。作用域内的变量增加被引用状态，不立即回收。

3. 查看内存使用
  使用process.memoryUsage()能查看堆中内存使用情况。
  使用 new Array 创建超大数组，然后逐次push进一个全局变量中，直至超出堆内存大小，退出node进程。
  代码见 useMemory.js
  使用 os.totalmem(),os.freemem()能够查看系统的内存。
  堆外内存。
  Buffer 使用的是堆外内存。
  代码见 bufferMemory.js

4. 内存泄漏
  内存，缓存？
  Limit Cache
  LRU 缓存
  进程外缓存，redis memcached
  内存泄露排查工具

5. 大内存使用
  一， 使用流，stream 继承自 emitter
  二， 使用buffer
